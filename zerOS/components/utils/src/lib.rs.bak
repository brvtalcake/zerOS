// #![cfg_attr(not(test), no_std)]
// #![cfg_attr(not(test), no_main)]
#![no_std]
#![no_main]
#![allow(non_snake_case)]
#![allow(incomplete_features)]
#![allow(internal_features)]
#![feature(transmutability)]
#![feature(decl_macro)]
#![feature(associated_type_defaults)]
// #![feature(generic_const_exprs)]
#![feature(const_trait_impl)]
#![feature(auto_traits)]
#![feature(core_intrinsics)]
#![feature(phantom_variance_markers)]
#![feature(f16)]
#![feature(f128)]
#![feature(custom_test_frameworks)]
#![feature(never_type)]
#![feature(min_specialization)]
#![feature(const_destruct)]
#![feature(sized_hierarchy)]
#![feature(cfg_select)]
#![feature(const_type_name)]

use core::{
	any::Any,
	hint::assert_unchecked,
	mem::{self, Assume, TransmuteFrom}
};

pub use rustc_demangle::{demangle, try_demangle};
use zerOS_static_assertions::static_assert;

use crate::cmp::{ConstOrd, ConstPartialEq};

pub mod cmp;
#[cfg(false)]
pub mod meta;
pub mod str;

pub macro function() {{
	fn f() {}
	const fn type_name_of<T: ~const core::marker::Destruct>(_: T) -> &'static str
	{
		::core::any::type_name::<T>()
	}
	const {
		const TMP: &'static [u8] = type_name_of(f).as_bytes();
		unsafe { str::from_utf8_unchecked(TMP.first_chunk::<{ TMP.len() - 3 }>().unwrap()) }
	}
}}

mod function_macro_sanity_checks
{
	use super::*;

	const fn fnname() -> &'static str
	{
		function!()
	}

	static_assert!(fnname().const_eq("zerOS_utils::function_macro_sanity_checks::fnname"));
}

pub trait IntoAnyIter<'item, 'collection>
{
	fn into_any_iter(self) -> impl Iterator<Item = &'item (dyn Any + 'static)> + 'collection;
}

pub trait IntoAnyIterMut<'item, 'collection>
{
	fn into_any_iter_mut(self) -> impl Iterator<Item = &'item mut (dyn Any + 'static)> + 'collection;
}

impl<'item, 'collection, C, I> IntoAnyIter<'item, 'collection> for &'collection C
where
	&'collection C: IntoIterator<Item = &'item I>,
	I: Any
{
	fn into_any_iter(self) -> impl Iterator<Item = &'item (dyn Any + 'static)> + 'collection
	{
		let tmp = self.into_iter().map(|elem| elem as &dyn Any);
		tmp
	}
}

impl<'item, 'collection, C, I> IntoAnyIter<'item, 'collection> for &'collection mut C
where
	&'collection mut C: IntoIterator<Item = &'item mut I>,
	I: Any
{
	fn into_any_iter(self) -> impl Iterator<Item = &'item (dyn Any + 'static)> + 'collection
	{
		self.into_iter().map(|elem| elem as &dyn Any)
	}
}

impl<'item, 'collection, C, I> IntoAnyIterMut<'item, 'collection> for &'collection mut C
where
	&'collection mut C: IntoIterator<Item = &'item mut I>,
	I: Any
{
	fn into_any_iter_mut(self) -> impl Iterator<Item = &'item mut (dyn Any + 'static)> + 'collection
	{
		self.into_iter().map(|elem| elem as &mut dyn Any)
	}
}

pub type VoidResult<E> = Result<(), E>;

pub macro likely($boolean:expr) {
	::core::hint::likely(($boolean) as bool)
}

pub macro unlikely($boolean:expr) {
	::core::hint::unlikely(($boolean) as bool)
}

#[macro_export]
macro_rules! alignment_of {
	(    ) => {
		0
	};
	(u8  ) => {
		1
	};
	(i8  ) => {
		1
	};
	(f8  ) => {
		1
	};
	(u16 ) => {
		2
	};
	(i16 ) => {
		2
	};
	(f16 ) => {
		2
	};
	(u32 ) => {
		4
	};
	(i32 ) => {
		4
	};
	(f32 ) => {
		4
	};
	(u64 ) => {
		8
	};
	(i64 ) => {
		8
	};
	(f64 ) => {
		8
	};
	(u128) => {
		16
	};
	(i128) => {
		16
	};
	(f128) => {
		16
	};
	($other:ty) => {
		const { ::core::mem::align_of::<$other>() }
	};
}

#[macro_export]
/// # TODO
/// This is technically `* __CHAR_BIT__` but no idea how to get that info from
/// rust
macro_rules! width_of {
	($typ:ty) => {
		($crate::size_of!($typ) * 8)
	};
}

#[macro_export]
macro_rules! size_of {
	(    ) => {
		0
	};
	(u8  ) => {
		1
	};
	(i8  ) => {
		1
	};
	(f8  ) => {
		1
	};
	(u16 ) => {
		2
	};
	(i16 ) => {
		2
	};
	(f16 ) => {
		2
	};
	(u32 ) => {
		4
	};
	(i32 ) => {
		4
	};
	(f32 ) => {
		4
	};
	(u64 ) => {
		8
	};
	(i64 ) => {
		8
	};
	(f64 ) => {
		8
	};
	(u128) => {
		16
	};
	(i128) => {
		16
	};
	(f128) => {
		16
	};
	($other:ty) => {
		const { ::core::mem::size_of::<$other>() }
	};
}

#[macro_export]
macro_rules! ensure_is_fragment_kind {
	(expr, ($($expansion:tt)*), ($good:expr)) => {
		$($expansion)*
	};
	(expr, ($($expansion:tt)*), ($($bad:tt)*)) => {
		compile_error!(
			concat!(
				"\"", stringify!($($bad)*), "\"",
				" is not a valid macro expression (\":expr\")"
			)
		)
	};
	(expr, ($good:expr)) => {
		$good
	};
	(expr, ($($bad:tt)*)) => {
		compile_error!(
			concat!(
				"\"", stringify!($($bad)*), "\"",
				" is not a valid macro expression (\":expr\")"
			)
		)
	};

	(type, ($($expansion:tt)*), ($good:ty)) => {
		$($expansion)*
	};
	(type, ($($expansion:tt)*), ($($bad:tt)*)) => {
		compile_error!(
			concat!(
				"\"", stringify!($($bad)*), "\"",
				" is not a valid macro type (\":ty\")"
			)
		)
	};
	(type, ($good:ty)) => {
		$good
	};
	(type, ($($bad:tt)*)) => {
		compile_error!(
			concat!(
				"\"", stringify!($($bad)*), "\"",
				" is not a valid macro type (\":ty\")"
			)
		)
	};
}

#[macro_export]
macro_rules! func_at {
	(@GET_EXPR[$($address:tt)*]) => {
		core::mem::transmute::<*const (), _>(
			$crate::ensure_is_fragment_kind!(expr, ($($address)*)) as _
		)
	};

	(@GET_EXPR[$($address:tt)*] as $($fnty:tt)*) => {
		core::mem::transmute::<
			*const (),
			$crate::ensure_is_fragment_kind!(type, ($($fnty)*))
		>(
			$crate::ensure_is_fragment_kind!(expr, ($($address)*)) as _
		)
	};

	(@GET_EXPR[$($tokens:tt)*] $next:tt $($rest:tt)*) => {
		$crate::func_at!(@GET_EXPR[$($tokens)* $next] $($rest)*)
	};

	($($tokens:tt)+) => {
		$crate::func_at!(@GET_EXPR[] $($tokens)+)
	};
}

pub fn assume_aligned<T: Copy>(src: T) -> T
where
	T: TransmuteFrom<T, { Assume::ALIGNMENT }>
{
	unsafe { <T as TransmuteFrom<T, { Assume::ALIGNMENT }>>::transmute(src) }
}

pub const unsafe fn with_lifetime<'from, 'to, T: ?Sized>(from: &'from T) -> &'to T
{
	unsafe { mem::transmute(from) }
}

pub const unsafe fn with_lifetime_mut<'from, 'to, T: ?Sized>(from: &'from mut T) -> &'to mut T
{
	unsafe { mem::transmute(from) }
}

pub const fn static_assume_lt<T: Copy>(value: T, max: T) -> T
where
	T: ~const ConstOrd
{
	assert!(value.const_lt(&max));
	unsafe {
		assert_unchecked(value.const_lt(&max));
	}
	value
}

/// Trait to retrieve the size of a type.
///
/// # Examples
/// TODO
//#[sealed]
// pub trait GetSize
//{
// 	type Value;
//
// 	const VALUE: usize;
//}
//
//#[sealed]
// impl<T: ?Sized> GetSize for T
//{
// 	default type Value = U<0>;
//
// 	default const VALUE: usize = 0;
//}
//
//#[sealed]
// impl<T: Sized> GetSize for T
// where
// 	Const<{ mem::size_of::<T>() }>: ToUInt
//{
// 	type Value = U<{ mem::size_of::<T>() }>;
//
// 	const VALUE: usize = mem::size_of::<T>();
//}

#[cfg(false)]
mod sanity_checks
{
	use typenum::{U0, U4, U8, assert_type_eq};
	use zerOS_static_assertions::static_assert;

	use crate::meta::*;

	struct Zst;

	struct Dependant<T: ?Sized>(T);

	type Dst = Dependant<[u8]>;

	// assert_type_eq!(<Zst as GetSize>::Value, U0);
	// static_assert!(<Zst as GetSize>::VALUE == 0);
	//
	// assert_type_eq!(<Dst as GetSize>::Value, U0);
	// static_assert!(<Dst as GetSize>::VALUE == 0);
	//
	// assert_type_eq!(<() as GetSize>::Value, U0);
	// static_assert!(<() as GetSize>::VALUE == 0);
	//
	// assert_type_eq!(<i32 as GetSize>::Value, U4);
	// static_assert!(<i32 as GetSize>::VALUE == 4);
	//
	// assert_type_eq!(<Dependant<Zst> as GetSize>::Value, U0);
	// static_assert!(<Dependant<Zst> as GetSize>::VALUE == 0);
	//
	// assert_type_eq!(<Dependant<i32> as GetSize>::Value, U4);
	// static_assert!(<Dependant<i32> as GetSize>::VALUE == 4);
	//
	// cfg_select! {
	// target_pointer_width = "64" => {
	// assert_type_eq!(<&i32 as GetSize>::Value, U8);
	// static_assert!(<&i32 as GetSize>::VALUE == 8);
	// },
	// target_pointer_width = "32" => {
	// assert_type_eq!(<&i32 as GetSize>::Value, U4);
	// static_assert!(<&i32 as GetSize>::VALUE == 4);
	// },
	// _ => {
	// compile_error!();
	// }
	// }

	assert_type_eq!(tuint!(SizeOf<Zst>), U0);
	static_assert!(val!(SizeOf<Zst>) == 0);

	assert_type_eq!(tuint!(SizeOf<Dst>), U0);
	static_assert!(val!(SizeOf<Dst>) == 0);

	assert_type_eq!(tuint!(SizeOf<i32>), U4);
	static_assert!(val!(SizeOf<i32>) == 4);

	assert_type_eq!(tuint!(SizeOf<Dependant<Zst>>), U0);
	static_assert!(val!(SizeOf<Dependant<Zst>>) == 0);

	assert_type_eq!(tuint!(SizeOf<Dependant<i32>>), U4);
	static_assert!(val!(SizeOf<Dependant<i32>>) == 4);

	cfg_select! {
		target_pointer_width = "64" => {
			assert_type_eq!(tuint!(SizeOf<&i32>), U8);
			static_assert!(val!(SizeOf<&i32>) == 8);
		},
		target_pointer_width = "32" => {
			assert_type_eq!(tuint!(SizeOf<&i32>), U4);
			static_assert!(val!(SizeOf<&i32>) == 4);
		},
		_ => {
			compile_error!();
		}
	}
}
