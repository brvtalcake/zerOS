#!/usr/bin/env python3

import os
import sys
import argparse
from string import Template

def parse_cmdline() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description='Internal build script to generate section info')
    parser.add_argument(
        '-c', '--output-cfile',
        type=str,
        required=False,
        default=None,
        help='Output C file'
    )
    parser.add_argument(
        '-r', '--output-rsfile',
        type=str,
        required=False,
        default=None,
        help='Output Rust file'
    )
    parser.add_argument(
        '-l', '--output-linkerfile',
        type=str,
        required=False,
        default=None,
        help='Output linker file'
    )
    parser.add_argument(
        '-i', '--input-linkerfile',
        type=str,
        required=True,
        help='Input templated linker file'
    )
    parser.add_argument(
        'sections',
        type=str,
        nargs='+',
        help='Sections to generate info for'
    )
    return parser.parse_args()

def main() -> int:
    args = parse_cmdline()

    section_csyms = Template(
"""
// --- SECTIONINFO START: ${section} ---
extern const symbol zerOS_${section}_start;
extern const symbol zerOS_${section}_end;
static const size_t zerOS_${section}_size = (size_t)((uintptr_t)(const void*)zerOS_${section}_end - (uintptr_t)(const void*)zerOS_${section}_start);
// --- SECTIONINFO END: ${section} ---
"""
    )
    section_rssyms = Template(
"""
unsafe extern "C"
{
    pub unsafe static zerOS_${section}_start: LinkerSym;
    pub unsafe static zerOS_${section}_end  : LinkerSym;
}
lazy_static! {
    #[allow(non_upper_case_globals)]
    pub static ref zerOS_${section}_size: usize = {
        unsafe {
            (zerOS_${section}_end   as usize) -
            (zerOS_${section}_start as usize)
        }
    };
}
"""
    )
    section_ldsyms = Template(
"""
/* --- SECTIONINFO START: ${section} --- */
ASSERT(LOADADDR(.${section}) == ABSOLUTE(ADDR(.${section})), "Section ${section} is not loaded at the correct address");

. = ALIGN(CONSTANT(MAXPAGESIZE) / 64);
zerOS_${section}_start = LOADADDR(.${section});

. = ALIGN(CONSTANT(MAXPAGESIZE) / 64);
zerOS_${section}_end = LOADADDR(.${section}) + SIZEOF(.${section});
/* --- SECTIONINFO END: ${section} --- */
"""
    )
    todump_csyms : str = ""
    todump_rssyms: str = ""
    todump_ldsyms: str = ""

    for sec in args.sections:
        todump_csyms  += section_csyms .substitute(section=sec)
        todump_rssyms += section_rssyms.substitute(section=sec)
        todump_ldsyms += section_ldsyms.substitute(section=sec)

    todump_csyms  = f"\n// --- SECTIONINFO AUTOGENERATED BY {os.path.realpath(__file__)}, START ---\n" \
                  + "#ifndef __ZEROS_SECTIONINFO_H__\n"                                                \
                  + "#define __ZEROS_SECTIONINFO_H__\n"                                                \
                  + "#include <stddef.h>\n"                                                            \
                  + "#include <misc/symbol.h>\n"                                                       \
                  + todump_csyms                                                                       \
                  + "#endif\n"                                                                         \
                  + f"\n// --- SECTIONINFO AUTOGENERATED BY {os.path.realpath(__file__)}, END ---\n"
    todump_rssyms = f"\n// --- SECTIONINFO AUTOGENERATED BY {os.path.realpath(__file__)}, START ---\n" \
                  + "pub mod __linker_symbols\n"                                                       \
                  + "{\n"                                                                              \
                  + "    #![allow(dead_code)]\n"                                                       \
                  + "    use core::ffi::c_void;\n"                                                     \
                  + "    use lazy_static::lazy_static;\n"                                              \
                  + "    pub type LinkerSym = *const c_void;\n"                                        \
                  + todump_rssyms.replace('\n', '\n    ', todump_rssyms.count('\n') - 1)               \
                  + "}\n"                                                                              \
                  + f"\n// --- SECTIONINFO AUTOGENERATED BY {os.path.realpath(__file__)}, END ---\n"
    todump_ldsyms = f"\n/* --- SECTIONINFO AUTOGENERATED BY {os.path.realpath(__file__)}, START --- */\n" \
                  + todump_ldsyms                                                                         \
                  + f"\n/* --- SECTIONINFO AUTOGENERATED BY {os.path.realpath(__file__)}, END --- */\n"
    
    if args.output_cfile is not None:
        _files: str = args.output_cfile
        for filepath in _files.split(','):
            with open(filepath, 'w') as f:
                f.write(todump_csyms)
                f.flush()
    
    if args.output_rsfile is not None:
        _files: str = args.output_rsfile
        for filepath in _files.split(','):
            with open(filepath, 'w') as f:
                f.write(todump_rssyms)
                f.flush()

    if args.input_linkerfile is not None:
        with open(args.input_linkerfile, 'r') as fr:
            _content = fr.read().replace("!!!__GENSECTION_FILL__!!!", todump_ldsyms)
            _files: str = args.output_linkerfile
            for filepath in _files.split(','):
                with open(filepath, 'w') as fw:
                    fw.write(_content)
                    fw.flush()

    return 0

def main_wrapper() -> None:
    try:
        sys.exit(main())
    except Exception as e:
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == '__main__':
    main_wrapper()

    